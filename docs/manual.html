<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>manual</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="manual_files/libs/clipboard/clipboard.min.js"></script>
<script src="manual_files/libs/quarto-html/quarto.js"></script>
<script src="manual_files/libs/quarto-html/popper.min.js"></script>
<script src="manual_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="manual_files/libs/quarto-html/anchor.min.js"></script>
<link href="manual_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="manual_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="manual_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="manual_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="manual_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="styles.css">
</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#softwarová-aplikace-val4plan" id="toc-softwarová-aplikace-val4plan" class="nav-link active" data-scroll-target="#softwarová-aplikace-val4plan"><span class="header-section-number">1</span> Softwarová aplikace val4plan</a>
  <ul class="collapse">
  <li><a href="#funkcionalita" id="toc-funkcionalita" class="nav-link" data-scroll-target="#funkcionalita"><span class="header-section-number">1.1</span> Funkcionalita</a></li>
  <li><a href="#způsoby-využití-use-cases" id="toc-způsoby-využití-use-cases" class="nav-link" data-scroll-target="#způsoby-využití-use-cases"><span class="header-section-number">1.2</span> Způsoby využití (Use cases)</a></li>
  <li><a href="#vývoj" id="toc-vývoj" class="nav-link" data-scroll-target="#vývoj"><span class="header-section-number">1.3</span> Vývoj</a></li>
  <li><a href="#distribuce" id="toc-distribuce" class="nav-link" data-scroll-target="#distribuce"><span class="header-section-number">1.4</span> Distribuce</a></li>
  <li><a href="#vstupní-data" id="toc-vstupní-data" class="nav-link" data-scroll-target="#vstupní-data"><span class="header-section-number">1.5</span> Vstupní data</a></li>
  </ul></li>
  <li><a href="#postup-instalace-software-val4plan" id="toc-postup-instalace-software-val4plan" class="nav-link" data-scroll-target="#postup-instalace-software-val4plan"><span class="header-section-number">2</span> Postup instalace software val4plan</a>
  <ul class="collapse">
  <li><a href="#instalace-r" id="toc-instalace-r" class="nav-link" data-scroll-target="#instalace-r"><span class="header-section-number">2.1</span> Instalace R</a></li>
  <li><a href="#stažení-balíčku-val4plan" id="toc-stažení-balíčku-val4plan" class="nav-link" data-scroll-target="#stažení-balíčku-val4plan"><span class="header-section-number">2.2</span> Stažení balíčku <em>val4plan</em></a></li>
  <li><a href="#instalace-balíčku-val4plan" id="toc-instalace-balíčku-val4plan" class="nav-link" data-scroll-target="#instalace-balíčku-val4plan"><span class="header-section-number">2.3</span> Instalace balíčku <em>val4plan</em></a></li>
  </ul></li>
  <li><a href="#práce-s-val4plan" id="toc-práce-s-val4plan" class="nav-link" data-scroll-target="#práce-s-val4plan"><span class="header-section-number">3</span> Práce s <em>val4plan</em></a>
  <ul class="collapse">
  <li><a href="#odhadování-parametrů-modelu" id="toc-odhadování-parametrů-modelu" class="nav-link" data-scroll-target="#odhadování-parametrů-modelu"><span class="header-section-number">3.1</span> Odhadování parametrů modelu</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">manual</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="softwarová-aplikace-val4plan" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="softwarová-aplikace-val4plan"><span class="header-section-number">1</span> Softwarová aplikace val4plan</h2>
<p>Softwarová aplikace val4plan umožňuje na základě <a href="#fig-hedonicke-ceny" class="quarto-xref">obr&nbsp;1</a> dat parametrů nemovitostí, veřejných statků a cen nemovitostí odhadovat statisticky významné vlivy veřejných statků na cenu nemovitosti. Softwarová aplikace je open-source software distribuovaná pod licencí GPL3 a je volně dostupná na internetových stránkách <a href="http://val4plan.cz" title="http://val4plan.cz">val4plan</a>.</p>
<div id="fig-hedonicke-ceny" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hedonicke-ceny-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/hedonicke_ceny.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hedonicke-ceny-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Obr&nbsp;1: val4plan vyhodnocuje efekty jednotlivých charakteristik nemovitosti včetně charakteristick okolí na cenu nemovitosti.
</figcaption>
</figure>
</div>
<section id="funkcionalita" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="funkcionalita"><span class="header-section-number">1.1</span> Funkcionalita</h3>
<p>Aplikace nabízí následující funkcionalitu:</p>
<ul>
<li><p><strong>načítání dat z externích zdrojů a jejich vstupní úpravu</strong> (výběr vzorku dat pro zvolené území, výběr atributů, které jsou relevantní pro následné zpracování);</p></li>
<li><p><strong>výpočet proměnných (metrik)</strong>, které popisují okolí nemovitostí, včetně analyzovaných veřejných statků;</p></li>
<li><p><strong>doplnění chybějících hodnot proměnných</strong> vzorkováním (sampling) údajů z různě velkých okolí nemovitostí;</p></li>
<li><p><strong>tvorba souborů bytů</strong>, jak bytů nabízených na trhu nemovitostí, tak také syntetických bytů, které representují celý bytový fond: soubory nabízených bytů slouží k estimaci parametrů modelů a soubory syntetických bytů slouží k predikci efektů veřejných statků a jejich změn;</p></li>
<li><p><strong>generování alternativních souborů syntetických bytů</strong>, které odrážejí změny v poskytování veřejných statků;</p></li>
<li><p><strong>estimace koeficientů modelů</strong>, zobrazení jejich koeficientů a dalších parametrů, uložení estimovaných modelů na disk pro další využití, zejména pro predikci cen nemovitostí;</p></li>
<li><p><strong>predikce dopadů změn v poskytování veřejných statků</strong> a obecně změn charakteristik v okolí nemovitosti.</p></li>
</ul>
</section>
<section id="způsoby-využití-use-cases" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="způsoby-využití-use-cases"><span class="header-section-number">1.2</span> Způsoby využití (Use cases)</h3>
<p>Aplikace umožňuje:</p>
<ul>
<li><p><strong>odhadovat efekty veřejných statků</strong>, případně jakékoli proměnné popisující území, na stávající nemovitosti i na jakkoli definované hypotetické nemovitosti. Aplikaci lze používat pro odhad ceny jak u stávající, tak také plánované výstavby;</p></li>
<li><p><strong>odhadovat efekty změny poskytování veřejného statku</strong>, případně jakékoli proměnné popisující území, na stávající nemovitosti nebo hypotetické (plánované) nemovitosti. Lze ověřovat jak počátek, tak také ukončení poskytování určitého veřejného statku (například vytvoření nového parku), případně marginální změny v kvalitě nebo rozsahu stávajícího nebo hypotetického veřejného statku (například rozšíření parku).</p></li>
</ul>
</section>
<section id="vývoj" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="vývoj"><span class="header-section-number">1.3</span> Vývoj</h3>
<p>Softwarová aplikace val4plan poskytuje robustní sadu nástrojů pro realizaci praktických ekonometrických analýz ověřování dopadů změn v prostředí. Koncepce otevřené, modulární aplikace umožňuje její další rozšiřování, zejména:</p>
<ul>
<li><p>přidávání dalších datových zdrojů a definici nových metrik;</p></li>
<li><p>tvorbu nových typů modelů (dalších typů regresních analýz);</p></li>
<li><p>tvorbu nástrojů vizualizace efektů změn veřejných statků.</p></li>
</ul>
</section>
<section id="distribuce" class="level3" data-number="1.4">
<h3 data-number="1.4" class="anchored" data-anchor-id="distribuce"><span class="header-section-number">1.4</span> Distribuce</h3>
<p>Aplikace je realizovaná v jazyce R a je distribuovaná pod licencí GPL3 ve formě R Package (R balíček) <a href="http://val4plan.cz" title="http://val4plan.cz">val4plan</a>. Softwarový balíček je možné nainstalovat v prostředí UNIX (Linux), Windows a MacOS a spouštět po nainstalování volně dostupného interpretu jazyka <a href="https://www.r-project.org/" title="https://www.r-project.org/">R</a>. Distribuce ve formě R Package zajišťuje integritu jednotlivých částí programu s knihovnami, které program využívá (dependencies), se vstupními daty, které jsou pro program nezbytné a s dokumentací zdrojového kódu a uživatelským manuálem. Software je možné ovládat z příkazové řádky operačního systému nebo ze základního terminálu jazyka R (R Console). Po nainstalování balíčku je potřeba nastavit adresářovou strukturu pro ukládání vstupů a výstupů.</p>
</section>
<section id="vstupní-data" class="level3" data-number="1.5">
<h3 data-number="1.5" class="anchored" data-anchor-id="vstupní-data"><span class="header-section-number">1.5</span> Vstupní data</h3>
<p>Software pracuje s rozsáhlou databází vstupních údajů, jejichž výčet a struktura jsou popsány dále v této e-příloze. Naprostá většina zdrojů poskytuje otevřená data. Využití některých zdrojů je ale omezeno licenčními podmínkami. Týká se to zejména dat o aktuálních cenách nemovitostí, které vlastní a spravují poradenské a realitní společnosti působící na trhu nemovitostí a dat Registru sčítacích obvodů, které spravuje Český statistický úřad. Řešitelé projektu mají veškerá data k dispozici, ostatní potenciální uživatelé se musí s vlastníky a správci dat dohodnout na podmínkách jejich využití.</p>
</section>
</section>
<section id="postup-instalace-software-val4plan" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="postup-instalace-software-val4plan"><span class="header-section-number">2</span> Postup instalace software val4plan</h2>
<section id="instalace-r" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="instalace-r"><span class="header-section-number">2.1</span> Instalace R</h3>
<p>Pro spuštění softwarové aplikace je nutné nainstalovat interpret jazyka R. Spolu s tím je nainstalována i R Console, prostřednictvím které uživatel aplikaci ovládá. Pokud již máte R na vašem počítači naistalované, lze tento krok přeskočit. Dbejte ale na to, aby nainstalovaná verze R byla aktuální.</p>
<p>Nejdříve si nainstalujte <a href="https://www.r-project.org/" title="https://www.r-project.org/">R</a>:</p>
<ol type="1">
<li><p>Jděte na download R, zvolte libovolný repozitář, ze kterého bude R stažen (například https://cloud.r-project.org/)</p></li>
<li><p>zvolte operační systém počítače, na kterém má být sotware nainstalován, například <em>Download R for Windows</em>)</p></li>
<li><p>Zvolte <em>Install R for the first time</em> a stáhněte si instalátor</p></li>
<li><p>Spusťte instalátor R (.exe soubor) a následujte instrukcí instalace</p></li>
</ol>
<p>Po instalaci spusťte naintalovaný program (např. R 4.4.1) a objeví s R Console.</p>
</section>
<section id="stažení-balíčku-val4plan" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="stažení-balíčku-val4plan"><span class="header-section-number">2.2</span> Stažení balíčku <em>val4plan</em></h3>
<p>Stáhněte si balíček <a href="http://val4plan.cz" title="http://val4plan.cz">val4plan</a> z webových stránek projektu https://val4plan.cz a uložte jej na lokální disk.</p>
</section>
<section id="instalace-balíčku-val4plan" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="instalace-balíčku-val4plan"><span class="header-section-number">2.3</span> Instalace balíčku <em>val4plan</em></h3>
<p>Před instalací balíču nejdříve odstraníme stávající balíček (pokud je již nainstalovaný) pomocí následujícího příkadu zadaného do R Console:</p>
<p><code>remove.packages("val4plan")</code></p>
<p>Následujícím příkazem nainstalujeme knihovnu <code>devtools</code>, která slouží k instalaci balíčků:</p>
<p><code>install.packages("devtools")</code></p>
<p>a příkazem</p>
<p><code>library(devtools)</code></p>
<p>knihovnu načteme do paměti počítače.</p>
<p>V dalším kroku instalujeme balíček <code>val4plan</code> do počítače. Cestu nastavíme dle uložení balíčku na vašem lokálním disku. Balíček automaticky stáhne všechny další R balíčky, které potřebuje ke své práci. Instalace může trvat deset i více minut. Použijte následující příkaz, ve kterém upravíte cestu k baličku:</p>
<p><code>devtools::install_local("D:\\Val4Plan\\software_balicek\\val4plan_0.1.0.tar.gz")</code></p>
<p>Nyní je software nainstalován.</p>
</section>
</section>
<section id="práce-s-val4plan" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="práce-s-val4plan"><span class="header-section-number">3</span> Práce s <em>val4plan</em></h2>
<p>Balíček nejdříve nahrajte do paměti příkazem.</p>
<p><code>library(val4plan)</code></p>
<p>Tento příkaz je nutné provést po každém spuštění <em>R Console</em>. V prvním kroku je nutné nastavit cestu ke kořenovému adresáři projektu, ve kterém jsou umístěné pracovní adresáře, do kterých program ukládá data. Pokud pracujeme s více projekty, které mají oddělená data, potom lze tímto příkazem vytvořit pro každý projekt samostatný kořenový adresář. Cestu k adresáři upravte dle vámi zvoleného místa na disku.</p>
<p><code>set_path_to_data("D:\\Val4Plan\\testik")</code></p>
<p>V dalším kroku je nutné provést počáteční nastavení programu: adresáře, cesty k adresářům a logovací soubor. Tyto operace se se provádí jediným příkazem</p>
<p><code>init_default()</code>,</p>
<p>který vytvoří výchozí pracovní adresáře pro ukládání vstupních a výstupních dat v této struktuře <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<pre><code>kořenový adresář/
  byty_orig/
  verejne_statky_orig/
  nabidky_byty/
  synteticke_byty/
  verejne_statky_stav/
  verejne_statky_alt/
  modely/
  predikce/
</code></pre>
<p>Pro práci s modelem bude nutné do těchto adresářů vložit vstupní data (to za Vás program automaticky neudělá). Ukážeme si, která data by měly jednotlivé adresáře obsahovat.</p>
<p>Adresář <code>byty_orig</code> obsahuje soubory údajů o bytech a domech, zejména:</p>
<ul>
<li><p>data Registru sčítacích obvodů a budov (<a href="https://www.czso.cz/csu/rso/registr_scitacich_obvodu" title="https://www.czso.cz/csu/rso/registr_scitacich_obvodu">RSO</a>) včetně údajů Technicko-ekonomických parametrů budov (TEP): využití těchto dat je poskytovatelem dat zpoplatněno;</p></li>
<li><p>data o transakcích nemovitostí od subjektů poskytujících tato data. Struktura datového souboru je definována dále v příloze; licenci k používání těchto dat je nutné obdržet od poskytovatelů dat;</p></li>
<li><p>data o plošných parametrech bytů ze SLDB. Licenci k používání dat je nutné získat od správce dat Českého statistického úřadu (ČSÚ).</p></li>
</ul>
<p>Struktura a formát výše uvedených údajů bytů a domů je uveden dále v el.příloze</p>
<p>Do složky <code>verejne_statky_orig</code> je nutné vložit původní geodata o území ve formátu shape, na základě kterých software počítá dle zvolených metrik jednotlivé proměnné, a ty poté ukládá do složky <code>verejne_statky_stav</code>, případně <code>verejne_statky_alt</code>. V případě, kdy jsou proměnné již vypočítané, postačí, když ve složce <code>verejne_statky_orig</code> bude soubor s názvem <code>OKRESY</code>, který je volně ke stažení z webových stránek <a href="http://val4plan.cz" title="http://val4plan.cz">val4plan</a>.</p>
<p>Adresář <code>verejne_statky_stav</code> obsahuje proměnné o stavu území, jejichž hodnoty byly odvozeny z vrstev uložených ve složce <code>verejne_statky_orig</code>. Tyto soubory jsou uloženy ve formátu shape a lze je již spočítané stáhnout z webových stránek <a href="http://val4plan.cz" title="http://val4plan.cz">val4plan</a>.</p>
<p>Adresář <code>verejne_statky_alt</code> obsahuje soubory informací o hypotetickém stavu území, který je porovnáván se současným stavem území obsaženým v adresáři <code>verejne_statky_stav</code>. Tyto soubory vznikají modifikací stavových souborů obsahujích veřejný statek, který je modifikován. Obvykle se postupuje tak, že soubor, který obsahuje daný veřejný statek obsažený v adresáři <code>verejne_statky_orig</code> je modifikován v externím nástroji GIS (např. QGIS nebo ARcGIS) a posléze nahrán do adresáře <code>verejne_statky_alt</code>.</p>
<p>Adresář <code>modely</code> obsahuje vstupní a výstupní soubory související s vlastními hedonickými modely cen. Vstupním souborem je definice modelu uložená ve výměnném formátu <code>json</code>. Příklad definice modelu lze stáhnout z webových stránek <a href="http://val4plan.cz" title="http://val4plan.cz">val4plan</a>.</p>
<p>Na základě vstupní definice modelu je provedena estimace (odhad) parametrů modelu, například příkazem <code>get_estimated_model_ols()</code>. Výstupem je několik souborů, o kterých se zmíníme později. Jedním ze souborů je uložený estimovaný model (serializovaný objekt modelu) v souboru s příponou <code>.rda</code>, který lze kdykoliv v budoucnosti načíst zpět do paměti počítače příkazem <code>load_model()</code>. Takto uložené modely umožňují provádět predikci změn cen nemovitostí bez nutnosti re-estimovat modely před každým použitím.</p>
<p>Do zbylých adresářů není nutné žádná data předem nahrávat, software do těchto adresářů automaticky ukládá jak dílčí, tak i finální výstupy.</p>
<p>V adresáři <code>nabidky_byty</code> budou uloženy údaje o bytech nabízených na trhu nemovitostí s vyhodnocenými proměnnými a doplněnými chybějícími hodnotami proměnných. Tyto údaje poslouží k estimaci hedonických modelů.</p>
<p>V adresáři <code>synteticke_byty</code> budou uloženy údaje o syntetických bytech, které se nalézají na hodnoceném území s vyhodnocenými proměnnými a doplněnými chybějícími hodnotami proměnných. Tyto údaje poslouží k predikci cen nemovitostí.</p>
<p>Do adresáře <code>predikce</code> budou uložené predikované údaje o cenách nemovitostí.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Zjednodušený postup pro predikci</p>
<p>V případě, kdy je záměrem uživatele „pouze“ predikovat ceny nemovitostí, postačuje pouze vložit do složky <code>verejne_statky_stav</code> soubor proměnných popisujících stav území, a do adresáře <code>modely</code> nahrát estimovaný model uložený v souboru typu <code>.rda</code>. Všechny tyto soubory lze stáhnout ze webových stránek <a href="http://val4plan.cz" title="http://val4plan.cz">val4plan</a>. V případě, kdy je potřeba vyhodnocovat dopad změny některé z charakteristik, je nutné vrstvu změněné charakteristiky uložit do složky <code>verejne_statky_alt</code>.</p>
</div>
</div>
<p>Po spuštění a počátečním nastavení software lze provádět řadu analýz. <em>val4plan</em> předpokládá dva základní způsoby využití:</p>
<ul>
<li><p><strong><em>odhadování (estimace) parametrů modelu</em></strong>, které representují hedonické ceny jednotlivých charakteristik nemovitostí a jejich okolí včetně sledovaných veřejných statků;</p></li>
<li><p><strong><em>odhadování agregovaných dopadů (efektů)</em></strong> změn veřejných statků na ceny residenčních nemovitostí.</p></li>
</ul>
<p>Estimace modelů je prováděna odborníky, kteří mají přístup k datům a mají potřebné kompetence v oblasti statistického usuzování. Kromě vlastní estimace parametrů modelů je nutné najít vhodnou formu hedonické funkce a identifikovat charakteristiky, které budou následně testovány. Obvykle se vytvoří řada alternativních modelů, jejichž kvalitu hodnotíme s využítím celé řady diagnostik. Nakonec zvolíme nejlepší model a odhady jeho parametrů interpretujeme jako výsledné odhady hedonických cen. Jak alternativní, tak výsledný nejlepší model lze následně uložit pro další využití v budoucnosti. Primárním účelem aplikace <em>val4plan</em> je tento proces tvorby alternativních modelů a jejich vyhodnocení zjednodušit a zrychlit, nicméně stále je tento process po odborné stránce náročný.</p>
<p>Naopak odhadování agregovaných efektů předpokládá, že byl vytvořen model a byly estimovány jeho parametry. Uživatel proto nemusí být kompetentní v oblasti statistického usuzování a může připravený model použít přímo k ověřování efektů změn veřejného statku na a) jednotlivé nemovitosti a za b) souhrnně za jednotlivé veřejné statky.</p>
<p>V následujících částech textu ukážeme:</p>
<ul>
<li><p>Estimaci parametrů modelu, které representují hedonické ceny</p></li>
<li><p>Využití estimovaného modelu na hodnocení efektů nových stanice metra D</p></li>
<li><p>Využití estimovaného modelu na hodnocení efektů nového parku (hypotetický příklad)</p></li>
</ul>
<p>Výzkumy hedonických cen obecně ukazují, že dopady veřejných statků na byty v bytových domech se liší od dopadů na byty v rodinných domech. Z toho důvodu budou v uvedených příkladech vytvořeny specifické modely pro každý segment bytového fondu. Cílem je ukázat možnosti a postupy rozdělení (segmentace) vzorku nemovitostí s cílem aplikovat specifické modely pro jednotlivé segmenty.</p>
<section id="odhadování-parametrů-modelu" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="odhadování-parametrů-modelu"><span class="header-section-number">3.1</span> Odhadování parametrů modelu</h3>
<p>Proces odhadování parametrů modelu prochází následujícími kroky:</p>
<ol type="1">
<li><p>Příprava vzorku údajů o nabízených bytech k prodeji</p></li>
<li><p>Zadání a odhadování parametrů modelu</p></li>
</ol>
<p>Obvykle je nutné nejdříve vyhodnotit proměnné z hlediska stavu území. Nastavení na hodnocení stavu území se provádí voláním funkce:</p>
<p><code>set_proces_stav()</code></p>
<p>V tomto nastavení bude program připravovat podklady pro základní scénář, který representuje (nebo je prohlášen) za současný stav. Aplikace bude ukládat vyhodnocené proměnné do základního scénáře <code>verejne_statky_stav</code>.</p>
<section id="příprava-vzorku-údajů-o-nabízených-bytech-k-prodeji" class="level4" data-number="3.1.1">
<h4 data-number="3.1.1" class="anchored" data-anchor-id="příprava-vzorku-údajů-o-nabízených-bytech-k-prodeji"><span class="header-section-number">3.1.1</span> Příprava vzorku údajů o nabízených bytech k prodeji</h4>
<p>V tomto kroku se provádí dvě operace:</p>
<ol type="1">
<li><p>načtení souboru nabízených bytů</p></li>
<li><p>doplnění proměnných a chybějících hodnot v tomto souboru</p></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Přípravu vzorků provádíme pouze tehdy, pokud již takový soubor nebyl dříve vytvořen. Vytvoření souboru je časově velice náročné, doba výpočtu se může pohybovat až v řádu desítek hodin. V případě, kdy soubor byl již vytvořen, lze tento krok přeskočit a soubor o nabízených bytech doplněný o veškeré další údaje načíst přímo z úložiště.</p>
</div>
</div>
<section id="načtení-souboru-nabízených-bytů" class="level5" data-number="3.1.1.1">
<h5 data-number="3.1.1.1" class="anchored" data-anchor-id="načtení-souboru-nabízených-bytů"><span class="header-section-number">3.1.1.1</span> Načtení souboru nabízených bytů</h5>
<p>Následujícím příkazem je do paměti načten soubor nabízených bytů v bytových domech:</p>
<p><code>nabidky_bd = get_nab_byty_prodej()</code></p>
<p>Objekt <code>nabidky_bd</code> obsahuje vlastní charakteristiky bytů uvedených v nabídkách bytů a připojených údajů <em>RSO</em>. Tento soubor má ale velké množství chybějících hodnot a hlavně neobsahuje celou řadu údajů o okolí bytů. Tyto údaje údaje doplníme v následujícím kroku.</p>
</section>
<section id="doplnění-proměnných-a-chybějících-hodnot-v-tomto-souboru" class="level5" data-number="3.1.1.2">
<h5 data-number="3.1.1.2" class="anchored" data-anchor-id="doplnění-proměnných-a-chybějících-hodnot-v-tomto-souboru"><span class="header-section-number">3.1.1.2</span> Doplnění proměnných a chybějících hodnot v tomto souboru</h5>
<p>Výpočet charakteristik okolí bytů provádí funkce <code>impute_byty()</code>. Tato funkce pro každý byt vyhodnotí všechny proměnné popisující okolí a u všech proměnných doplní případné chybějící hodnoty.</p>
<p>Doplnění všech proměnných ke všem pozorováním může na běžném počítači trvat až 60 hodin. Proto se komplexní evaluace všech proměnných provádí pouze v nejnutnějším případě, zejména, pokud jsou k dispozici nová data nabídek bytů na trhu. Seznam proměnných, které mají být aktualizované, je uložen v souboru formátu json v adresáři admin. Zde je uveden příklad souboru, který obsahuje kompletní výčet proměnných.</p>
<p>Častější bude potřeba aktualizovat pouze jednu nebo několik málo proměnných a ostatní ponechat nezměněné. V takovém případě výše uvedený seznam proměnných zúžíme pouze na ty, které chceme aktualizovat Funkce poté přepočítá pouze ty proměnné, které jsou uvedeny v seznamu a u ostatních proměnných ponechá původní hodnoty.</p>
<p>Kromě snížení počtu proměnných lze také zmenšit vzorek nabízených bytů. Velikost souboru se určuje parametrem <code>sample_size</code>. Pokud uvedeme <code>sample_size = 0</code>, bude vyhodnocen celý původní soubor bytů.</p>
<p>Posledním atributem funkce je název souboru typu <code>.rds</code>, do kterého bude uložen vyhodnocený a doplněný soubor bytů k pozdějšímu požití. Tento soubor bude automaticky uložen v adresáři <code>nabidky_byty</code>.</p>
<p>Příklad zadání funkce se všemi parametry:</p>
<p><code>nabidky_bd = impute_byty(nabidky_bd, sample_size = 0, name_json_seznam_promennych = "seznam_promennych", synthetic = F, "nabidky_bd")</code></p>
</section>
</section>
<section id="zadání-a-odhadování-parametrů-modelů" class="level4" data-number="3.1.2">
<h4 data-number="3.1.2" class="anchored" data-anchor-id="zadání-a-odhadování-parametrů-modelů"><span class="header-section-number">3.1.2</span> Zadání a odhadování parametrů modelů</h4>
<section id="zadání-modelu" class="level5" data-number="3.1.2.1">
<h5 data-number="3.1.2.1" class="anchored" data-anchor-id="zadání-modelu"><span class="header-section-number">3.1.2.1</span> Zadání modelu</h5>
<p>Soubor nabízených bytů obsahuje jak veškeré charakteristiky bytů a jejich okolí, tak také cenu, za kterou byl byt na trhu nabízen. Takový soubor lze využít pro odhadování parametrů modelu, které representují hedonické ceny jednotlivých charakteristik. Pro odhad parametrů hedonického modelu je nutné nejdříve definovat funkci, jejíž parametry budou odhadovány, tzv. hedonickou funkci.</p>
<p>Hedonická funkce je definována a uložena v zadávacím souboru typu <code>.json</code> uloženém v adresáři <code>modely</code>. Níže je uveden příklad zadání modelu:</p>
<pre><code>{
"nazev":["Model1"],

"popis":["Zkušební model"],

"zavisle":["log1p(P_nabidka_cena)"],

"nezavisle":[
    "qq", 
    "relevel(P_bud_obdobi_vystavby, ref = '1920-1945')",
    "I(iad_centrum_cas/10)",
        "I(vhd_centrum_cas/10)",
        "log1p(P_nabidka_plochauzitna)",
        "balcony",
        "parking_space",
        "elevator",
        "garage",
        "terrace",
        "panel",
        "I(P_dist_min_zel&lt;100)",
        "log1p(I(P_dist_min_zs/1000))",
        "log1p(I(P_dist_min_zdrav/1000))",
        "log1p(I(P_dist_min_obchod_centrum/1000))",
        "I(P_dist_min_nemocnice&lt;600)",
    "I(P_dist_min_silnice&lt;100)",
        "I(pc_park_600/9)",
        "I(pc_orna_600/9)",
        "I(pc_les_600/9)",
        "nadan",
        "I(P_near_metro_dist&lt;800)",
        "I(P_near_bus_dist&lt;800)",
        "I(P_near_tram_dist&lt;800)",
        "I(P_near_train_dist&lt;800)",
        "I(P_znecisteni_nox)",
        "P_podil_vs_zsj",
        "P_zahrada",
        "I(P_obytna_hustota_zsj/100)"
]
}</code></pre>
<p>V zadávacím souboru je kromě definice funkce (závisle a nezávisle proměnných) rovněž nutné uvést název a popis modelu. Zadávací soubor umožňuje provést základní transformace proměnných, například:</p>
<ul>
<li><p>dělení obytné hustoty konstantou: <code>"I(P_obytna_hustota_zsj/100)"</code></p></li>
<li><p>transformace z kontiuální proměnné na proměnnnou binární je: <code>"I(P_near_bus_dist&lt;800)"</code></p></li>
</ul>
<p>Jak je patrné, pro tyto číselné operace platí, že musí být uzavřeny do speciální funkce <code>I()</code>.</p>
<p>Pro transformaci proměnných lze použít řadu funkcí, například lze použít funkce přirozeného logaritmu proměnné zvětšené o číslo 1: <code>log1p(P_nabidka_cena)</code> (posun proměnné o 1 umožˇbuje vypočítat logaritmus i pro nulové hodnoty proměnné).</p>
<p>U kategorických proměnných lze určit, která z kategorií bude referenční: například funkce <code>relevel(P_bud_obdobi_vystavby, ref = '1920-1945')</code>, určuje kategorii <code>'1920-1945'</code> kategorické proměnné <code>P_bud_obdobi_vystavby</code> jako referenční pro vyhodnocení efektů.</p>
<p>Výše uvedená možnost zadávat funkční transformace proměnných přímo do specifikace modelu přináší zjednodušení v tom, že proměnné není nutné transformovat v původních datech a tím zbytečně data zmnožovat a znepřehledňovat. Provádění transformací až při zadání konkrétního modelu usnadňuje experimentování s množstvím alternativních specifikací hedonické funkce a zároveň přehledně dokumentuje proces hledání optimální funkce a modelu.</p>
<p>Z výše uvedeného vyplývá, že uživatel může vytvářet libovolný počet alternativních specifikací uložených v různě nazvaných souborech typu <code>.json</code>. Pro načtení do <em>val4plan</em> musí být tyto soubory vždy uloženy v adresáři <code>modely</code>.</p>
<p>Pro vytvoření prvního základního modelu načteme z adresáře modely například soubor <code>m_nab_bd.json</code>:</p>
<p><code>m_formula = load_formula("m_nab_bd")</code></p>
<p>Pro estimaci modelu budeme také potřebovat vzorek nabízených bytů, který jsme vytvořili v předešlém kroku. Objekt vzorku <code>nabidky_bd</code> bychom měli mít stále v paměti počítače, pokud jsme ale mezitím ukončili <em>R</em> nebo restartovali počítač, potom tento objekt již v paměti nemáme, a je potom nutné jej nahrát ze souboru <code>nabidky_bd</code> uloženém v adresáři <code>nabídky</code> (soubor má formát <code>.rds</code>, ale ten se při zadávání funkcí neuvádí). načtení souboru nabídek provedeme příkazem:</p>
<p><code>nabidky_bd = load_byty("nabidky_byty", "nabidky_bd", sample_size = 0)</code></p>
<p>Atribut <code>sample_size</code> umožňuje do paměti nahrát pouze určitý počet údajů, zde je ale nastavena výchozí hodnota 0, která znamená, že budou použity všechny údaje.</p>
<p>Řada záznamů bytů obsahuje ceny, které jsou odchýlené od průměrných hodnot. Tyto záznamy mohou zkreslovat odhad hedonických cen a jsou proto ze vstupních dat odstraněny následujícím příkazem:</p>
<p><code>nabidky_bd = filter_price_outliers_byty(nabidky_bd, min_cena = 1500000, max_cena = 20000000, min_cena_m2 = 25000, max_cena_m2 = 150000)</code></p>
<p>Tato funkce odstraní odchylné hodnoty menší než je uživatelem stanovená minimální cena (výchozí hodnota 1 500 000) nebo větší než uživatelem stanovená cena (výchozí hodnota 20 000 000) nebo nižší než je uživatelem stanovená minimální cena za m<sup>2</sup> obytné plochy (výchozí hodnota 25 000) nebo je vyšší než je uživatelem stanovená maximální cena za m<sup>2</sup> obytné plochy (výchozí hodnota 150 000). Pokud vyhovují výchozí hodnoty funkce, není nutné tyto hodnoty v příkazu uvádět a stačí zadat tuto zkrácenou verzi funkce:</p>
<p><code>nabidky_bd = filter_price_outliers_byty(nabidky_bd)</code></p>
</section>
<section id="Estimace" class="level5" data-number="3.1.2.2">
<h5 data-number="3.1.2.2" class="anchored" data-anchor-id="Estimace"><span class="header-section-number">3.1.2.2</span> Estimace základního modelu</h5>
<p>Nejdříve si ukážeme estimaci základního neprostorového modelu <em>OLS (Ordinary Least Squre)</em>. Estimace (a fakticky vytvoření modelu) se provádí funkcí <code>estimate_model_ols()</code>, která jako argument přijímá objekt hedonické funkce, zde <code>m_formula</code>,vzorek bytů nabízených na realitním trhu <code>nabidky_bd</code> a název modelu, a zároveň souboru, ve kterém bude estimovaný model uložen. Estimovaný model bude uložen v adresáři <code>modely</code>.</p>
<p><code>model_ols_bd = estimate_model_ols(m_formula, nabidky_bd, "model_ols_bd")</code></p>
<p>Estimační funkce má několik výstupů. Kromě vlastního objektu representujícího model, zde <code>model_ols_bd</code>, ukládá estimační funkce do adresáře <code>modely</code> několik dalších souborů:</p>
<ul>
<li><p><code>nazevmodelu.html</code>, ve které je tabulka odhadů koeficientů jednotlivých proměnných s uvedením intervalu spolehlivosti na hladině spolehlivosti 95%;</p></li>
<li><p><code>nazevmodelu_diagnostics.txt</code>, který presentuje řadu testů kvality modelu, např. <em>test normality odchylek modelu</em>, <em>test heteroskedasticity (Studentized Breusch-Pagan test)</em> nebo <em>Reset test</em>, který ukazuje na nelineární vztahy mezi závisle a nezávisle proměnnými;</p></li>
<li><p><code>nazevmodelu_basic_diagnostics.png</code>, který ukazuje čtyři základní grafy: <em>Residuals vs Fitted</em> umožňuje ověřit <em>homoskedasticitu a linearitu</em>, <em>Q-Q Residuals</em> ověřuje, zda mají odchylky modelu normální rozdělení, <em>Scale-Location</em> ověřuje <em>homoskedasticitu</em> a <em>Residuals vs Leverage</em> pomáhá identifikovat vlivné (influential) hodnoty;</p></li>
<li><p><code>nazevmodelu_residuals.png</code> ukazuje histogram odchylek modelu.</p></li>
</ul>
</section>
<section id="estimace-modelu-s-fixními-efekty" class="level5" data-number="3.1.2.3">
<h5 data-number="3.1.2.3" class="anchored" data-anchor-id="estimace-modelu-s-fixními-efekty"><span class="header-section-number">3.1.2.3</span> Estimace modelu s fixními efekty</h5>
<p>Výše uvedeným postupem jsme vytvořili <em>základní regresní model OLS (Ordinary Least-Square)</em>, který se obvykle využívá k diagnostice prostorových závislostí a jako základní srovnávací model pro hodnocení dalších složitějších modelů. Další, alternativní modely se vytvářejí obdobným postupem. Lze vytvořit neomezené množství alternativních modelů a ty mezi sebou porovnávat.</p>
<p>Například lze vytvořit model fixních efektů, který eliminuje velkou část heterogenity charakteristik území. Model <em>fixních efektů</em> vyhodnocuje průměrné efekty charakteristik (intercepty) pro jednotlivá katastrální území na území hl. m. Praha a pro jednotlivé obce mimo hl. m. Praha. K tomu účelu slouží indikátorová proměnná <code>ku_obec</code>, která je přidaná do seznamu proměnných v zadávacím souboru. Soubor <code>m_nab_bd_fe_dist_centre.json</code> v adresáři modely ukazuje příklad zadání modelu s fixními efekty. Tuto specifikaci načteme do paměti:</p>
<p><code>m_formula_fe = load_formula("m_nab_bd_fe")</code></p>
<p>Pro estimaci modelu se volá stejná estimační funkce, jako v případě předešlého modelu <em>OLS</em> (stále se jedná o Ordinary Least Square model, tentokrát pouze s přidanou indikátorovou proměnnou pro identifikaci katastráního území, ve kterém se nachází byt):</p>
<p><code>model_ols_fe_bd = estimate_model_ols(m_formula = m_formula_fe, nabidky_byty_doplnene = nabidky_bd, naz_modelu = "model_ols_fe_bd")</code></p>
<p>Model využívá stejný vzorek nabízených bytů, jako základní model <em>OLS</em>. Proto jako argument funkce zadáme objekt <code>nabidky_bd</code>. Pokud tento objekt máme stále v paměti, potom se vzorek bytů nemusí nahrávat do paměti.</p>
<p>Nyní jsme vytvořili dva modely a lze je porovnat, jak na úrovni jednotlivých koeficientů, tak na úrovni obecných diagnostik. Pro porovnání obou modelů použijeme funkci:</p>
<p><code>summarize_two_models("OLS and FE modely_bd", model_ols_bd, model_ols_fe_bd)</code></p>
<p>Jako první argument funkce uvedeme text názvu souboru, který bude ve formátu <code>.html</code> uložen v adresáři <code>modely</code>. Další dva argumenty jsou objekty obou vytvořených modelů. V souboru je tabulka <mark>(XXXX odkaz na přílohu, soubor OLS and FE modely_bd.html)</mark>, která ukazuje odhady efektů jednotlivých proměnných na závisle proměnnou. V závorce je uveden interval spolehlivosti na hladině spolehlivosti 95%.</p>
<p>Obdobným postupem vytvoříme základní dva modely <em>OLS</em> pro segment rodinných domů. Postup je shodný, proto uvedeme pouze sekvenci příkazů.</p>
<pre><code>nabidky_rd = load_byty("nabidky_byty", "nabidky_rd", sample_size = 0)
nabidky_rd = filter_price_outliers_domy(nabidky_rd)
m_formula = load_formula("m_nab_rd")
model_ols_rd = estimate_model_ols(m_formula = m_formula, nabidky_byty_doplnene = nabidky_rd, naz_modelu = "model_ols_rd")
m_formula = load_formula("m_nab_rd_fe")
model_ols_fe_rd = estimate_model_ols(m_formula = m_formula, nabidky_byty_doplnene = nabidky_rd, naz_modelu = "model_ols_fe_rd")
summarize_two_models("OLS and FE modely RD", model_ols_rd, model_ols_fe_rd)</code></pre>
<p>Soubor nabízených bytů v rodinných domech jsme v prvním příkazu nahráli ze souboru, ve kterém je vzorek doplněný o veškeré proměnné a jejich případné chybějící hodnoty. V případě, že budeme chtít tento soubor nechata znovu vypočítat, nahradíme první příkaz těmito dvěma příkazy (pozor výpočet může trvat několik hodin):</p>
<pre><code>nabidky_rd = get_nab_domy_prodej()
nabidky_rd = impute_byty(nabidky_rd, sample_size = 0, name_json_seznam_promennych = "seznam_promennych", synthetic = F, "nabidky_rd")</code></pre>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Příkaz <code>filter_price_outliers_domy()</code>, který odstraňuje odchylné hodnoty u bytů v rodiných domech, má nastavené následující výchozí hodnoty: <code>min_cena = 3 000 000</code>, <code>max_cena = 20 000 000</code>, minimální cena za m<sup>2</sup> obytné plochy <code>min_cena_m2 = 25 000</code>, maximální cena za m<sup>2</sup> obytné plochy <code>max_cena_m2 = 150 000</code>. Pokud nám tyto výchozí hodnoty vyhovují, není potřeba je v příkazu zadávat.</p>
</div>
</div>
<p><a href="#Estimace">odkaz na nadpis</a></p>
</section>
</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Pokud se tyto adresáře v kořenovém adresáři již nacházejí, potom program žádné nové adresáře nevytvoří a stávající adresáře a jejich obsah bude zachován.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>